# Warp Core NFT Marketplace

This directory contains a basic on-chain NFT marketplace for ERC1155 NFTs.

## Getting Started
If you are looking to get started with the contracts as quickly as possible, reference deployments are available in the tests. The deployment will need to:
- deploy `Registry`, `Sale`, and/or `Auction`
- register `Sale` and/or `Auction` through the `Registry` via `setContractStatus`
- set the system wallet for fees on `Registry` via `setSystemWallet`
- set any ERC20 tokens being accepted on `Registry` via `setCurrencyStatus`

A sample deploy script (untested) is provided in `scripts/deployMarketplace.ts`.

**Note:** * the current `mint` in the `MockERC1155` and the marketplace tests is the `mintWithUriAutoTokenId` (same for batch) - that'll need to be changed in any prod implementation, and may cause trouble with the tests when changed.

## Architecture

This section is merely a brief description of the architecture of the project - a fuller description follows. (I hope, I haven't written those yet, but man I hope they follow). In addition, there is full natspec on the contracts which is autogenerated into docs in the `docs/` directory found in the root directory, which will provide a full specification.

### `Registry`

`Registry` contains basic information about the ecosystem in basic setter and getter functions. Notably, it can be used to verify a contract is a part of the ecosystem, or that a certain token is accepted. The setter functions are restricted by an OpenZeppelin `Ownable` module, meaning they will only be able to be called by the contract deployer initially, though the deployer can call `transferOwnership` to transfer this to another address.

### `Sale`

`Sale` provides a marketplace for fixed price sales. The contract custodies NFTs being sold and also any funds from sales.

### `Auction`

`Auction` provides a marketplace for first-price auctions. The contract custodies the NFTs being auctioned, and also any funds from bidding.

## Common Patterns and Useful Information

In the current setup, only NFTs from contracts recognized by the Registry can be auctioned or sold. This means that a contract must be approved via `setContractStatus` on the Registry before an NFT from the contract can be incorporated in `createSale` or `createAuction`.

Both `Sale` and `Auction` support [ERC2981](https://eips.ethereum.org/EIPS/eip-2981) royalties, and use them for royalty payments. This also means that NFT contracts _must_ support ERC2981 in order to work with the `Auction` or `Sale` contracts as they are now, though. As a result, `createAuction` and `createSale` both check that the NFT contract is 2981-compliant, and revert if it is not.

There is a system fee implemented which mimics the style of ERC2981. There is a `feeInfo` function in the `Registry` which when input a price returns the address the fees should be sent to and the amount to be paid in fees.

Accounting is done via `claimableBalance`. Any funds a user can withdraw will show as `claimableBalance`, which can be queried via `getClaimableBalance` with the user's address and the token's address as args. (A native token (such as ETH on Ethereum) uses `0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa`, and is referred to in the contracts as `ETH`, though is equally applicable to the native token of any other blockchain or rollup.)

The token accounting between `Auction` and `Sale` is separate, meaning that if (for example) a seller both sells NFTs on `Sale` and auctions NFTs on `Auction` that the funds will be separate and need to be withdrawn from both contracts separately.

Every sale or auction has a lifecycle, referred to as a `Status` in the contracts and tests. While it may make sense for the statuses to be an enum, at this juncture the statuses exist as strings. There is a slight difference between the possible statuses in `Auction` and `Sale` due to the different natures of fixed-price sales and first-price auctions. The statuses determine if the auction or sale has not yet started, is active, ended, or cancelled.

Auctions and sales can be cancelled by either the seller or the contract owner. In auctions, cancelling returns bids to `claimableBalance` and allows the NFT to be claimed seller. In sales, sold NFTs remain sold, and the funds paid to buy them remain in the seller's claimable balance. The remaining NFTs can be claimed by the seller.

An auction is resolved by the winner claiming the NFT. This moves their bid into the seller's `claimableBalance`. This can result in a "stuck" scenario where there is a winning bid, but the winner does not claim. Both the NFT and the funds of the winning bid would be locked in escrow. Due to this, there is a `resolveAuction` function which allows the contract owner to send the NFT to the highest bids address and move the funds of the bid to the seller's `claimableBalance`. This can only be called on an auction which has ended but has not been claimed.

## Tests

A comprehensive test suite is provided in `tests/marketplace/` with unit and scenario tests. This also serves as a reference for how to use the contracts. There is much room for refactoring and improving the tests, though the current coverage is quite high.

## Potential future features and improvements
* allow bidding on someone else's behalf (approvals)
* permits
* minimum bids must increase by
* switching statuses to enums

In addition, the current separate accounting systems is a pain point. A major refactor and optimization may be able to condense `Auction` and `Sale` into one contract, which would be a major improvement.

The system is a bit bulky since all information is stored on-chain, though I do think there are almost certainly still opportunities to optimize what information is written and how.